{{ license }}
"""{{ ClassName }} domain service impl"""

from __future__ import annotations

import io
import json
from typing import Type, Any

import pandas as pd
from loguru import logger
from pydantic import ValidationError
from starlette.responses import StreamingResponse

from src.main.app.core.constant import FilterOperators
from src.main.app.core.service.impl.base_service_impl import BaseServiceImpl
from src.main.app.core.utils import excel_util
from src.main.app.core.utils.validate_util import ValidateService
from src.main.app.enums import BusinessErrorCode
from src.main.app.exception.biz_exception import BusinessException
from src.main.app.mapper.{{ c_n }}_mapper import {{ CN }}Mapper
from src.main.app.model.{{ c_n }}_model import {{ CN }}Model
from src.main.app.schema.{{ c_n }}_schema import (
    List{{ CNs }}Request,
    {{ CN }},
    Create{{ CN }}Request,
    Update{{ CN }}Request,
    BatchDelete{{ CNs }}Request,
    Export{{ CNs }}Request,
    BatchCreate{{ CNs }}Request,
    Create{{ CN }},
    BatchUpdate{{ CNs }}Request,
    Update{{ CN }},
    Import{{ CNs }}Request,
    Import{{ CN }},
    Export{{ CN }},
    BatchPatch{{ CNs }}Request,
    BatchUpdate{{ CN }},
)
from src.main.app.service.{{ c_n }}_service import {{ CN }}Service


class {{ CN }}ServiceImpl(BaseServiceImpl[{{ CN }}Mapper, {{ CN }}Model], {{ CN }}Service):
    """
    Implementation of the {{ CN }}Service interface.
    """

    def __init__(self, mapper: {{ CN }}Mapper):
        """
        Initialize the {{ CN }}ServiceImpl instance.

        Args:
            mapper ({{ CN }}Mapper): The {{ CN }}Mapper instance to use for database operations.
        """
        super().__init__(mapper=mapper)
        self.mapper = mapper

    async def get_{{ c_n }}(
        self,
        *,
        id: int,
    ) -> {{ CN }}Model:
        {{ c_n }}_record: {{ CN }}Model = await self.mapper.select_by_id(id=id)
        if {{ c_n }}_record is None:
            raise BusinessException(BusinessErrorCode.RESOURCE_NOT_FOUND)
        return {{ c_n }}_record

    async def list_{{ c_ns }}(
        self, req: List{{ CNs }}Request
    ) -> tuple[list[{{ CN }}Model], int]:
        filters = {
            FilterOperators.EQ: {},
            FilterOperators.NE: {},
            FilterOperators.GT: {},
            FilterOperators.GE: {},
            FilterOperators.LT: {},
            FilterOperators.LE: {},
            FilterOperators.BETWEEN: {},
            FilterOperators.LIKE: {},
        }
        if req.parent_id is not None and req.parent_id != "":
            filters[FilterOperators.EQ]["parent_id"] = req.parent_id
        else:
            filters[FilterOperators.EQ]["parent_id"] = 0
        if req.id is not None and req.id != "":
            filters[FilterOperators.EQ]["id"] = req.id
        if req.name is not None and req.name != "":
            filters[FilterOperators.LIKE]["name"] = req.name
        if req.icon is not None and req.icon != "":
            filters[FilterOperators.EQ]["icon"] = req.icon
        if req.permission is not None and req.permission != "":
            filters[FilterOperators.EQ]["permission"] = req.permission
        if req.sort is not None and req.sort != "":
            filters[FilterOperators.EQ]["sort"] = req.sort
        if req.path is not None and req.path != "":
            filters[FilterOperators.EQ]["path"] = req.path
        if req.component is not None and req.component != "":
            filters[FilterOperators.EQ]["component"] = req.component
        if req.type is not None and req.type != "":
            filters[FilterOperators.EQ]["type"] = req.type
        if req.cacheable is not None and req.cacheable != "":
            filters[FilterOperators.EQ]["cacheable"] = req.cacheable
        if req.visible is not None and req.visible != "":
            filters[FilterOperators.EQ]["visible"] = req.visible
        if req.status is not None and req.status != "":
            filters[FilterOperators.EQ]["status"] = req.status
        if req.create_time is not None and req.create_time != "":
            filters[FilterOperators.EQ]["create_time"] = req.create_time
        sort_list = None
        sort_str = req.sort_str
        if sort_str is not None:
            sort_list = json.loads(sort_str)
        return await self.mapper.select_by_ordered_page(
            current=req.current,
            page_size=req.page_size,
            count=req.count,
            **filters,
            sort_list=sort_list,
        )

    async def get_children_recursively(
        self, *, parent_data: list[{{ CN }}Model], schema_class: Type[{{ CN }}]
    ) -> list[{{ CN }}]:
        if not parent_data:
            return []
        {{ c_n }}_list = [{{ CN }}(**record.model_dump()) for record in parent_data]
        return await self.mapper.get_children_recursively(
            parent_data={{ c_n }}_list, schema_class=schema_class
        )

    async def create_{{ c_n }}(self, req: Create{{ CN }}Request) -> {{ CN }}Model:
        {{ c_n }}_record: {{ CN }}Model = await self.mapper.select_by_name(
            name=req.{{ c_n }}.name
        )
        if {{ c_n }}_record is not None:
            raise BusinessException(BusinessErrorCode.MENU_NAME_EXISTS)
        {{ c_n }}: {{ CN }}Model = {{ CN }}Model(**req.{{ c_n }}.model_dump())
        return await self.save(data={{ c_n }})

    async def update_{{ c_n }}(self, req: Update{{ CN }}Request) -> {{ CN }}Model:
        {{ c_n }}_record: {{ CN }}Model = await self.retrieve_by_id(id=req.{{ c_n }}.id)
        if {{ c_n }}_record is None:
            raise BusinessException(BusinessErrorCode.RESOURCE_NOT_FOUND)
        {{ c_n }}_model = {{ CN }}Model(**req.{{ c_n }}.model_dump(exclude_unset=True))
        await self.modify_by_id(data={{ c_n }}_model)
        merged_data = {**{{ c_n }}_record.model_dump(), **{{ c_n }}_model.model_dump()}
        return {{ CN }}Model(**merged_data)

    async def delete_{{ c_n }}(self, id: int) -> None:
        {{ c_n }}_record: {{ CN }}Model = await self.retrieve_by_id(id=id)
        if {{ c_n }}_record is None:
            raise BusinessException(BusinessErrorCode.RESOURCE_NOT_FOUND)
        await self.mapper.delete_by_id(id=id)

    async def batch_get_{{ c_ns }}(self, ids: list[int]) -> list[{{ CN }}Model]:
        {{ c_n }}_records = list[{{ CN }}Model] = await self.retrieve_by_ids(ids=ids)
        if {{ c_n }}_records is None:
            raise BusinessException(BusinessErrorCode.RESOURCE_NOT_FOUND)
        if len({{ c_n }}_records) != len(ids):
            not_exits_ids = [id for id in ids if id not in {{ c_n }}_records]
            raise BusinessException(
                BusinessErrorCode.RESOURCE_NOT_FOUND,
                f"{BusinessErrorCode.RESOURCE_NOT_FOUND.message}: {str({{ c_n }}_records)} != {str(not_exits_ids)}",
            )
        return {{ c_n }}_records

    async def batch_create_{{ c_ns }}(
        self,
        *,
        req: BatchCreate{{ CNs }}Request,
    ) -> list[{{ CN }}Model]:
        {{ c_n }}_list: list[Create{{ CN }}] = req.{{ c_ns }}
        if not {{ c_n }}_list:
            raise BusinessException(BusinessErrorCode.PARAMETER_ERROR)
        {{ c_n }}_names = [{{ c_n }}.name for {{ c_n }} in {{ c_n }}_list]
        {{ c_n }}_records: list[{{ CN }}Model] = await self.mapper.select_by_names(
            names={{ c_n }}_names
        )
        if {{ c_n }}_records:
            exist_{{ c_n }}_names = [{{ c_n }}.name for {{ c_n }} in {{ c_n }}_records]
            raise BusinessException(
                BusinessErrorCode.MENU_NAME_EXISTS,
                f"{BusinessErrorCode.MENU_NAME_EXISTS.message}: {str(exist_{{ c_n }}_names)}",
            )
        data_list = [{{ CN }}Model(**{{ c_n }}.model_dump()) for {{ c_n }} in {{ c_n }}_list]
        await self.mapper.batch_insert(data_list=data_list)
        return data_list

    async def batch_update_{{ c_ns }}(
        self, req: BatchUpdate{{ CNs }}Request
    ) -> list[{{ CN }}Model]:
        {{ c_n }}: BatchUpdate{{ CN }} = req.{{ c_n }}
        ids: list[int] = req.ids
        if not {{ c_n }} or not ids:
            raise BusinessException(BusinessErrorCode.PARAMETER_ERROR)
        await self.mapper.batch_update_by_ids(
            ids=ids, data={{ c_n }}.model_dump(exclude_none=True)
        )
        return await self.mapper.select_by_ids(ids=ids)

    async def batch_patch_{{ c_ns }}(
        self, req: BatchPatch{{ CNs }}Request
    ) -> list[{{ CN }}Model]:
        {{ c_ns }}: list[Update{{ CN }}] = req.{{ c_ns }}
        if not {{ c_ns }}:
            raise BusinessException(BusinessErrorCode.PARAMETER_ERROR)
        update_data: list[dict[str, Any]] = [
            {{ c_n }}.model_dump(exclude_unset=True) for {{ c_n }} in {{ c_ns }}
        ]
        await self.mapper.batch_update(items=update_data)
        {{ c_n }}_ids: list[int] = [{{ c_n }}.id for {{ c_n }} in {{ c_ns }}]
        return await self.mapper.select_by_ids(ids={{ c_n }}_ids)

    async def batch_delete_{{ c_ns }}(self, req: BatchDelete{{ CNs }}Request):
        ids: list[int] = req.ids
        await self.mapper.batch_delete_by_ids(ids=ids)

    async def export_{{ c_ns }}_template(self) -> StreamingResponse:
        file_name = "{{ c_n }}_import_tpl"
        return await excel_util.export_excel(
            schema=Create{{ CN }}, file_name=file_name
        )

    async def export_{{ c_ns }}(self, req: Export{{ CNs }}Request) -> StreamingResponse:
        ids: list[int] = req.ids
        {{ c_n }}_list: list[{{ CN }}Model] = await self.mapper.select_by_ids(ids=ids)
        if {{ c_n }}_list is None or len({{ c_n }}_list) == 0:
            logger.error(f"No {{ c_ns }} found with ids {ids}")
            raise BusinessException(BusinessErrorCode.PARAMETER_ERROR)
        {{ c_n }}_page_list = [Export{{ CN }}(**{{ c_n }}.model_dump()) for {{ c_n }} in {{ c_n }}_list]
        file_name = "{{ c_n }}_data_export"
        return await excel_util.export_excel(
            schema=Export{{ CN }}, file_name=file_name, data_list={{ c_n }}_page_list
        )

    async def import_{{ c_ns }}(self, req: Import{{ CNs }}Request) -> list[Import{{ CN }}]:
        file = req.file
        contents = await file.read()
        import_df = pd.read_excel(io.BytesIO(contents))
        import_df = import_df.fillna("")
        {{ c_n }}_records = import_df.to_dict(orient="records")
        if {{ c_n }}_records is None or len({{ c_n }}_records) == 0:
            raise BusinessException(BusinessErrorCode.PARAMETER_ERROR)
        for record in {{ c_n }}_records:
            for key, value in record.items():
                if value == "":
                    record[key] = None
        {{ c_n }}_import_list = []
        for {{ c_n }}_record in {{ c_n }}_records:
            try:
                {{ c_n }}_create = Import{{ CN }}(**{{ c_n }}_record)
                {{ c_n }}_import_list.append({{ c_n }}_create)
            except ValidationError as e:
                valid_data = {
                    k: v
                    for k, v in {{ c_n }}_record.items()
                    if k in Import{{ CN }}.model_fields
                }
                {{ c_n }}_create = Import{{ CN }}.model_construct(**valid_data)
                {{ c_n }}_create.err_msg = ValidateService.get_validate_err_msg(e)
                {{ c_n }}_import_list.append({{ c_n }}_create)
                return {{ c_n }}_import_list

        return {{ c_n }}_import_list
